"""KAgent ParallelAgent with max_workers concurrency limiting."""

import asyncio
import logging
import time
from typing import AsyncGenerator

from google.adk.agents import ParallelAgent
from google.adk.agents.base_agent import BaseAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event
from google.genai.types import Content, Part
from opentelemetry import trace

from ..metrics import ParallelAgentMetrics, set_max_workers_metric

logger = logging.getLogger(__name__)
tracer = trace.get_tracer(__name__)


class KAgentParallelAgent(ParallelAgent):
    """ParallelAgent with configurable max_workers concurrency limiting.

    Extends Google ADK's ParallelAgent to add semaphore-based concurrency control,
    limiting the number of sub-agents executing concurrently to prevent resource
    exhaustion.

    Attributes:
        max_workers: Maximum number of sub-agents executing concurrently (default: 10)
        semaphore: Asyncio semaphore for concurrency control (initialized in __init__)
    """

    # Declare max_workers as a Pydantic field
    max_workers: int = 10
    namespace: str = "default"

    # Configure model to allow extra fields for semaphore
    model_config = {"extra": "allow", "arbitrary_types_allowed": True}

    def __init__(
        self,
        *,
        name: str,
        description: str = "",
        parent_agent: BaseAgent | None = None,
        sub_agents: list[BaseAgent] | None = None,
        max_workers: int = 5,
        namespace: str = "default",
        **kwargs,
    ):
        """Initialize KAgentParallelAgent with max_workers support.

        Args:
            name: Agent name
            description: Agent description
            parent_agent: Parent agent (optional)
            sub_agents: List of sub-agents to execute in parallel
            max_workers: Maximum concurrent sub-agents (default: 5, min: 1, max: 50)
            namespace: Kubernetes namespace for metrics (default: "default")
            **kwargs: Additional arguments passed to ParallelAgent
        """
        # Validate max_workers
        if not isinstance(max_workers, int):
            raise TypeError(f"max_workers must be int, got {type(max_workers)}")
        if max_workers < 1:
            raise ValueError(f"max_workers must be >= 1, got {max_workers}")
        if max_workers > 50:
            raise ValueError(f"max_workers must be <= 50, got {max_workers}")

        # Initialize parent with all fields including max_workers
        super().__init__(
            name=name,
            description=description,
            parent_agent=parent_agent,
            sub_agents=sub_agents or [],
            max_workers=max_workers,
            namespace=namespace,
            **kwargs,
        )

        # Create semaphore for concurrency control
        self.semaphore = asyncio.Semaphore(max_workers)

        # Initialize Prometheus metrics
        set_max_workers_metric(name, self.namespace, max_workers)

        logger.info(
            f"Initialized KAgentParallelAgent '{name}' with max_workers={max_workers}, "
            f"sub_agents={len(self.sub_agents)}"
        )

    async def run_async(self, parent_context: InvocationContext) -> AsyncGenerator[Event, None]:
        """Execute sub-agents in parallel with concurrency limiting.

        Overrides ParallelAgent.run_async() to add semaphore-based concurrency control.
        Each sub-agent acquires the semaphore before execution and releases it after
        completion (even on error).

        Args:
            parent_context: Invocation context from parent agent

        Yields:
            Event: Events generated by sub-agents during execution
        """
        with tracer.start_as_current_span(
            f"{self.name}.run_async",
            attributes={
                "kagent.agent.name": self.name,
                "kagent.agent.type": "parallel",
                "kagent.parallel.max_workers": self.max_workers,
                "kagent.parallel.sub_agent_count": len(self.sub_agents),
            },
        ) as span:
            logger.info(
                f"Starting KAgentParallelAgent '{self.name}' with "
                f"{len(self.sub_agents)} sub-agents, max_workers={self.max_workers}"
            )

            # Create tasks for all sub-agents
            tasks = []
            for idx, sub_agent in enumerate(self.sub_agents):
                task = asyncio.create_task(self._run_sub_agent_with_semaphore(sub_agent, parent_context, idx))
                tasks.append(task)

            # Wait for all tasks to complete and collect results
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # Yield events from all sub-agents
            completed_count = 0
            error_count = 0

            for idx, result in enumerate(results):
                if isinstance(result, Exception):
                    error_count += 1
                    sub_agent_name = self.sub_agents[idx].name
                    error_msg = str(result)
                    logger.error(
                        f"Sub-agent {sub_agent_name} failed: {error_msg}",
                        exc_info=result,
                    )
                    # Yield error event with proper structure
                    yield Event(
                        author=self.name,
                        content=Content(
                            parts=[Part(text=f"Error in sub-agent {sub_agent_name}: {error_msg}")],
                            role="model",
                        ),
                        error_code="SUB_AGENT_ERROR",
                        error_message=error_msg,
                        custom_metadata={"sub_agent": sub_agent_name, "error": True},
                    )
                else:
                    completed_count += 1
                    # Yield events from successful execution
                    for event in result:
                        yield event

            span.set_attribute("kagent.parallel.completed_count", completed_count)
            span.set_attribute("kagent.parallel.error_count", error_count)

            logger.info(
                f"KAgentParallelAgent '{self.name}' completed: {completed_count} successful, {error_count} errors"
            )

    async def _run_sub_agent_with_semaphore(
        self, sub_agent: BaseAgent, parent_context: InvocationContext, idx: int
    ) -> list[Event]:
        """Execute a single sub-agent with semaphore-based concurrency control.

        Args:
            sub_agent: Sub-agent to execute
            parent_context: Parent invocation context
            idx: Index of sub-agent in sub_agents list

        Returns:
            List of events generated by the sub-agent

        Raises:
            Exception: Any exception raised by the sub-agent (propagated to caller)
        """
        # Create metrics context manager
        metrics = ParallelAgentMetrics(agent_name=self.name, namespace=self.namespace)

        # Increment queue depth before waiting for semaphore
        metrics.inc_queue_depth()
        semaphore_wait_start = time.time()

        # Acquire semaphore (blocks if max_workers limit reached)
        async with self.semaphore:
            # Decrement queue depth once semaphore acquired
            metrics.dec_queue_depth()
            semaphore_wait_ms = (time.time() - semaphore_wait_start) * 1000

            with tracer.start_as_current_span(
                f"{self.name}.sub_agent[{idx}].{sub_agent.name}",
                attributes={
                    "kagent.agent.name": sub_agent.name,
                    "kagent.parallel.sub_agent_index": idx,
                    "kagent.parallel.semaphore_wait_ms": semaphore_wait_ms,
                    "kagent.parallel.max_workers": self.max_workers,
                },
            ) as span:
                if semaphore_wait_ms > 10:  # Log if waited more than 10ms
                    logger.debug(
                        f"Sub-agent {sub_agent.name} waited {semaphore_wait_ms:.1f}ms "
                        f"for semaphore (max_workers={self.max_workers})"
                    )

                execution_start = time.time()

                try:
                    # Track active execution with metrics
                    async with metrics:
                        # Clone parent context for isolated execution
                        # Use shallow copy to avoid copying unpicklable objects like locks
                        sub_context = parent_context.model_copy(deep=False)

                        # Execute sub-agent and collect events
                        events = []
                        async for event in sub_agent.run_async(sub_context):
                            events.append(event)

                    execution_ms = (time.time() - execution_start) * 1000
                    span.set_attribute("kagent.agent.execution_ms", execution_ms)
                    span.set_attribute("kagent.agent.event_count", len(events))

                    logger.debug(
                        f"Sub-agent {sub_agent.name} completed in {execution_ms:.1f}ms, generated {len(events)} events"
                    )

                    return events

                except Exception as e:
                    execution_ms = (time.time() - execution_start) * 1000
                    span.set_attribute("kagent.agent.execution_ms", execution_ms)
                    span.set_attribute("error", True)
                    span.record_exception(e)

                    logger.error(
                        f"Sub-agent {sub_agent.name} failed after {execution_ms:.1f}ms: {e}",
                        exc_info=e,
                    )

                    # Re-raise to be caught by gather()
                    raise
