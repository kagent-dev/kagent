"""KAgent SequentialAgent with shared session ID propagation for context continuity."""

import logging
from typing import AsyncGenerator

from google.adk.agents import SequentialAgent
from google.adk.agents.base_agent import BaseAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event
from opentelemetry import trace

logger = logging.getLogger(__name__)
tracer = trace.get_tracer(__name__)


class KAgentSequentialAgent(SequentialAgent):
    """SequentialAgent that propagates parent session ID to all sub-agents.

    This implementation ensures that all sub-agents in a sequential workflow
    operate on the SAME shared session, enabling context propagation as
    designed in EP-991. Each sub-agent can see events generated by previous
    sub-agents in the workflow.

    Key Difference from Google's SequentialAgent:
    - Google's SequentialAgent clones the parent context for each sub-agent
    - KAgentSequentialAgent passes the SAME parent context (no cloning)
    - This preserves the session ID, allowing sub-agents to append to the
      shared session and see accumulated events

    Attributes:
        name: Agent name
        description: Agent description
        sub_agents: List of sub-agents to execute sequentially
        namespace: Kubernetes namespace (for metrics/logging)

    Example:
        ```python
        workflow = KAgentSequentialAgent(
            name="deployment-workflow",
            description="Sequential deployment with shared context",
            sub_agents=[pre_check_agent, deploy_agent, validate_agent],
            namespace="production",
        )

        # All sub-agents will use the same session_id from parent_context
        async for event in workflow.run_async(parent_context):
            print(event)
        ```
    """

    namespace: str = "default"

    # Allow extra fields for compatibility with Pydantic models
    model_config = {"extra": "allow"}

    def __init__(
        self,
        *,
        name: str,
        description: str = "",
        parent_agent: BaseAgent | None = None,
        sub_agents: list[BaseAgent] | None = None,
        namespace: str = "default",
        **kwargs,
    ):
        """Initialize KAgentSequentialAgent with session propagation support.

        Args:
            name: Agent name
            description: Agent description (default: empty string)
            parent_agent: Parent agent reference (default: None)
            sub_agents: List of sub-agents to execute sequentially (default: empty list)
            namespace: Kubernetes namespace for logging/metrics (default: "default")
            **kwargs: Additional arguments passed to SequentialAgent

        Raises:
            TypeError: If sub_agents is not a list
            ValueError: If any sub_agent is not a BaseAgent instance
        """
        # Initialize parent SequentialAgent
        super().__init__(
            name=name,
            description=description,
            parent_agent=parent_agent,
            sub_agents=sub_agents or [],
            **kwargs,
        )

        # Store namespace for logging/metrics
        self.namespace = namespace

        logger.info(
            f"Initialized KAgentSequentialAgent '{name}' with "
            f"{len(self.sub_agents)} sub-agents in namespace '{namespace}'"
        )

    async def run_async(self, parent_context: InvocationContext) -> AsyncGenerator[Event, None]:
        """Execute sub-agents sequentially with shared session ID propagation.

        This method overrides SequentialAgent.run_async() to implement true
        context propagation. Key behaviors:

        1. **Shared Session**: All sub-agents receive the SAME parent_context
           (not cloned), ensuring they operate on the same session
        2. **Sequential Execution**: Sub-agents execute in order, each seeing
           events from previous sub-agents
        3. **Event Streaming**: Events from each sub-agent are yielded as they
           are generated
        4. **Error Handling**: Exceptions from sub-agents are propagated to
           the caller

        Session ID Propagation Flow:
        ```
        parent_context.session.id = "workflow-123"
            ↓
        Sub-Agent-1: Receives parent_context → session_id="workflow-123"
            └─> Generates events, appends to session "workflow-123"
            ↓
        Sub-Agent-2: Receives parent_context → session_id="workflow-123"
            └─> Fetches session "workflow-123", sees Sub-Agent-1's events
            └─> Generates its own events, appends to session "workflow-123"
            ↓
        Sub-Agent-N: Receives parent_context → session_id="workflow-123"
            └─> Sees ALL accumulated events from previous sub-agents
        ```

        Args:
            parent_context: Invocation context containing the shared session

        Yields:
            Event: Events generated by sub-agents during execution

        Raises:
            Exception: Any exception raised by a sub-agent (halts workflow)
        """
        with tracer.start_as_current_span(
            f"{self.name}.run_async",
            attributes={
                "kagent.agent.name": self.name,
                "kagent.agent.type": "sequential",
                "kagent.sequential.sub_agent_count": len(self.sub_agents),
                "kagent.session.id": parent_context.session.id,
                "kagent.user.id": parent_context.user_id,
            },
        ) as span:
            logger.info(
                f"Starting KAgentSequentialAgent '{self.name}' with "
                f"{len(self.sub_agents)} sub-agents, session_id='{parent_context.session.id}'"
            )

            # Execute sub-agents sequentially
            for idx, sub_agent in enumerate(self.sub_agents):
                with tracer.start_as_current_span(
                    f"{self.name}.sub_agent[{idx}].{sub_agent.name}",
                    attributes={
                        "kagent.agent.name": sub_agent.name,
                        "kagent.sequential.sub_agent_index": idx,
                        "kagent.session.id": parent_context.session.id,
                    },
                ):
                    logger.debug(
                        f"Executing sub-agent {idx}: {sub_agent.name} with session_id='{parent_context.session.id}'"
                    )

                    # CRITICAL: Pass parent_context directly (NO CLONING)
                    # This ensures session ID propagates to RemoteA2aAgent calls
                    try:
                        event_count = 0
                        async for event in sub_agent.run_async(parent_context):
                            event_count += 1
                            yield event

                        logger.debug(f"Sub-agent {sub_agent.name} completed, generated {event_count} events")

                    except Exception as e:
                        logger.error(
                            f"Sub-agent {sub_agent.name} failed: {e}",
                            exc_info=e,
                        )
                        span.set_attribute("error", True)
                        span.record_exception(e)
                        # Re-raise to halt workflow execution
                        raise

            logger.info(
                f"KAgentSequentialAgent '{self.name}' completed successfully, "
                f"all {len(self.sub_agents)} sub-agents executed"
            )
